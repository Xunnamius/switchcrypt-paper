

\subsection{Putting It All Together} \label{subsec:summary}

After describing the three main contributions, now we discuss
other details surrounding the three main components.


% ----------------------------------------- secure metadata
\mysub{Secure metadata management}
%
The focus of this paper is to implement mechanisms and policies to perform
flexible switching of cipher configurations that can be built on top of
existing block-level encryption module (aka. ``encryption driver'') that
already provides the management of the encryption data structures.  There
were a couple of open-source choices to start with such as Linux
\ts{dm-crypt} \cite{x}, \ts{cryptsetup} \cite{x},
% X: https://gitlab.com/cryptsetup/cryptsetup
\ts{cryptmount} \cite{y}, 
% x: https://sourceforge.net/projects/cryptmount/,
or StrongBox \cite{x},
% x: https://github.com/strongbox/strongbox
\hsg{please double check i'm correct}.  We decided to build atop StrongBox
because it already implements stream ciphers such as ChaCha which is more
secure than block cipher. 

\sys depends on several data structure management provided in StrongBox,
such as its 
%
transcation and rekeying journal (for never writing data
encrypted with the same key to the same location, hence avoiding pad reuse
violations), 
%
Merkle tree (for tracking the drive state such as
\hsg{explain a bit more}), 
%
monotonic counter (on a trusted hardware to
prevent rollbacks), 
%
keycount store (to derive the nugget's unique
encryption key from some master secret and limit the maximum length of any
plaintext input to ciphers), and 
%
per-nugget metadata (to store cipher-specific extra metadata
\hsg{true??}).  Every drive partition also has a ``head'' area that
indicates which cipher is currently active.

While we reuse some of the components, all of these are tightly integrated
to the ciphers that they implemented (specifically ChaCha, and \xxx).  We
had to untangle this, hence the contribution in the \sysB component where
we now expose more structured interfaces allowing cipher implementors to
natly build the metadata management of their cipher algorithm around the
interfaces.  More specifically, out of all the five \hsg{true??} StrongBox
components above, only \xxx can be reused as is, while the rest needs to
be modularized and rewritten.


% -------------------------------------------------------------------------
\mysub{Threat model under switching}


% confidentialitity
In terms of {\em confidentiality}, an adversary should not be able to reveal
any information about encrypted plaintext without the proper key.  As with
prior works, encryption is achieved via a binary additive approach: cipher
output (keystream) is combined with plaintext nugget contents using XOR,
with metadata to track writes and ensure that pad reuse never occurs
during overwrites and that the system can recover from crashes into a
secure state.
% data integrity
In terms of {\em data integrity}, an adversary should not be able to
tamper with ciphertext and it go unnoticed. Nugget integrity is tracked by
StrongBox's in-memory Merkle tree (see \cite[Section \xxx]{StrongBox} for
further details).

Switching strategies add an additional security concern not addressed by
prior work: even if we initiate a ``cipher switch,'' there may still be
data on the drive that was encrypted with an inactive configuration. Is
this a problem? For the Forward strategy, this implies data may at any
time be encrypted using the ``least desirable cipher''. For the Mirrored
and Selective strategies, the drive is partitioned into regions where
nuggets are guaranteed to be encrypted with each cipher, including the
``least desirable cipher''. However, in terms of confidentiality, the
confidentiality guarantee of SwitchCrypt can be reduced to the individual
confidentiality guarantees of the available ciphers used to encrypt
nuggets. \hsg{need to double check that this statement is still true,
  after I already rewrite the design section.}



% ------------------------------------------------------------------------
\mysub{Higher-level integration}
\sys expects a higher-level integration/policy that will tell \sys what kind of
switching should be performed and when.  For example, for the battery-life scenario,
\sys expects that the OS battery saver application will trigger the forward switching.
We provide more in the case studies section.


% ------------------------------------------------------------------------
\mysub{Generality}
%
\sys can be seen as a drop-in replacement for the popular Linux
\ts{dm-crypt} layer (encryption driver).  For performance reasons, just
like StrongBox, \sys recommends a log-based file system such as F2FS,
\xxx, or \xxx, which are commonly used for flash devices.  The reason for
this is that supporting streaming chipers is more efficient in storage
systems with no in-place updates.  \sys is a software solution, however
the same logic can be adopted to storage devices in the future, especially
flash devices.  For example, the no in-place update of the FTL nature will
help stream chipers be performance while at the same time users can use
other popular in-place update file systems such as ext4, btrfs, and xfs.



% -------------------------------------------------------------------------
\mysub{Switching modes pros/cons.}
%
\hsg{DO WE STILL NEED THIS DISCUSSION? convergence, waste, performance, etc.
THE FACT that the modes above are about case studies???
so it's known that there is no single best scenario.}

\if 0

\input{tab-switch2}

\tblref{tab-switch2} summarizes the higher level tradeoffs between the
three cipher switching strategies.

\textbf{Convergence.} Depending on the use case, the ability to quickly converge
the entire drive to a single cipher configuration without losing data is very
useful (see: \secref{usecases}). The near-instantaneous ``just forget the key''
nature of SSD Instant Secure Erase (ISE) implementations on modern
SSDs~\cite{ISE1,ISE2,ISE3} makes this a very fast process for the Mirrored
strategy. The Forward strategy is slow to converge compared to Mirrored since,
in the worse case, every nugget on the drive will require re-ciphering. The
Selective strategy is similarly slow to converge since entire regions of nuggets
must be moved and re-ciphered to prevent data loss; those regions could be
destroyed without moving data around using ISE too, which would be very fast,
but unlike Mirrored some data would be lost forever.

\textbf{Waste.} Unlike the other two strategies, using the Forward strategy does
not reduce the total usable space on the drive by the end-user, ciphertext
expansion notwithstanding. We refer to this as ``waste''. The Forward strategy
is not wasteful in this way because it allows differently-ciphered nuggets to
co-exist contiguously on the drive without special partitions. Since the
Mirrored and Selective strategies require partitioning the drive into some
number of regions---where the writeable size reported back to the OS is some
function of region size---there is a necessary reduction in usable space.

\textbf{Performance.} The Selective and Mirrored strategies can read data from
the drive with low overhead, reaching performance parity with prior work,
because they never have to deal with on-demand re-ciphering. This is because
switching ciphers using these two strategies amounts to offsetting the read
index so that it lands in the proper BODY partition on the drive, which has
little overhead. The Forward strategy also reads with low overhead except in the
case where a nugget was not encrypted with the active configuration. This
triggers re-ciphering on-demand, which can be costly if the workload constantly
touches unique nuggets and is small enough that cost is not amortized.

The Selective strategy also writes with low overhead because, like with reads,
an index offset is the only requirement. The Mirrored strategy, on the other
hand, can be up to two times slower for writes (when $C = 2$) compared to
baseline. Each additional region ($C > 2$) compounds the write penalty depending
on the workload. This is because each write is mirrored across \emph{all}
regions. As with reads, the Forward strategy writes with low overhead except in
the case where a nugget was not encrypted with the active configuration. This
triggers re-ciphering on-demand, which can be costly if the workload touches
unique nuggets and is small enough that cost is not amortized.\\

With these tradeoffs in mind: Mirrored is ideal when the drive must converge
quickly, write performance is not a primary concern, and drive space is
abundant; Selective is ideal when different data should be encrypted differently
and drive space is abundant; and Forward is ideal when some subset of nuggets
should be encrypted differently without wasting drive space. See
\secref{usecases} for specific scenarios that demonstrate these differences in
practice.

\fi
