
The benefits of choosing one cipher over another might include: 1)
improved performance (\ie{overall reduction in FDE overhead}), 2) reduced energy
use, 3) more useful security guarantees, and 4) the ability to encrypt devices
that would otherwise be too slow or energy-inefficient to support FDE.






On the one hand, stronger
security guarantees come with increased latency and threaten to balloon energy
consumption. On the other, capping total energy consumption requires tolerating
increased latency or weaker security guarantees.




% SEcurity model: (maybe add to the implementation section)  \sysB

When it comes to the security concern, StrongBox solves both the snapshot and
integrity problems by 1) never writing data encrypted with the same key to the
same location and 2) tracking drive state using a Merkle tree and monotonic
counter supported by trusted hardware to prevent rollbacks. This ensures data
manipulations cannot occur and guarantees confidentiality even when snapshots
are compared regardless of the stream cipher used. Unfortunately, restoring from
a backup necessitates a forced rollback of drive state, potentially opening us
back up to confidentiality-violating snapshot comparison
attacks~\cite{StrongBox}.



To truly address the security concern requires a cipher with an additional
security property: \emph{ciphertext randomization}. Without ciphertext
randomization, an attacker can map plaintexts to their ciphertext counterparts
during snapshot comparison, especially if they can predict what might be written
to certain drive regions. However, with ciphertext randomization, a cipher will
output a different ``random'' ciphertext even when given the same key, nonce,
and plaintext; this means, even after a forced rollback of system state and/or
legitimate restoration from a backup, comparing future writes is no longer
violates confidentiality because each snapshot will always consist of different
ciphertext regardless of the plaintext being encrypted or the state of the
drive. Using Freestyle~\cite{Freestyle}, a ChaCha20-based stream cipher that
supports ciphertext randomization, we can guarantee data confidentiality in this
way. So, we switch from StrongBox to an encryption driver that supports
Freestyle.

Unfortunately, like AES-XTS, Freestyle has significant overhead compared to the
original ChaCha20. In exchange for stronger security properties, Freestyle is up
to 1.6x slower than ChaCha20, uses more energy, has a higher initialization
cost, and expands the ciphertext which reduces total writeable drive
space~\cite{Freestyle}.





Further complicating matters is our final concern: a constrained energy budget.
Our example system is battery constrained. Even if we accepted trading off
performance, drive space, and energy for security in some situations, in other
situations we might prioritize reducing total energy use. For example, when we
trigger ``battery saver'' mode, we expect our device to conserve as much energy
as possible. It would be ideal if our device could pause backups and the
encryption driver could switch from the ciphertext-randomizing Freestyle
configuration back to our high performance energy-efficient ChaCha20
configuration when conserving energy is a top priority, and then switch back to
the Freestyle configuration when we connect to a charger and backups are
eventually resumed.

In this paper we present SwitchCrypt, a device mapper that can trade off between
these two configurations and others without compromising security or performance
or requiring the device be restarted. With prior work, the user must select a
static operating point in the energy-security-latency space at initialization
time and hope it is optimal across all workloads and cases. If they choose the
Freestyle configuration, their device will be slower and battery hungry even
when they are not backing up. If they choose the more performant ChaCha20
configuration, they risk confidentiality-violating snapshot comparison attacks.
SwitchCrypt solves this problem by encrypting data with the high performance
ChaCha20 when the battery is low and switching to Freestyle when plugged in and
syncing with the backup service resumes.


% =================================================================================
% =================================================================================
% =================================================================================


\subsection{Key Challenges} % ---- put it in the implementation section







% =================================================================================
% =================================================================================
% =================================================================================

\subsection{Strong Box Dependencies}



% dependent on StrongBox

Other than StrongBox, other implementations such as \xxx \hsg{any?} that has the
same components above can be reused. 


The drive itself is divided into a \emph{HEAD} section and \emph{BODY} section
upon initialization, illustrated in \figref{backstore}. The HEAD consists of
metadata headers written during initialization~\cite{StrongBox} along with the
\emph{Keycount Store}, \emph{Transaction Journal}, \emph{Rekeying Journal}, and
\emph{Per-Nugget Metadata}, each drive-backed. 

These components are used by the
\emph{Cryptographic Driver} together with the \emph{Cipher Switching Strategy}
implementations to enable efficient per-unit cipher switching.

The BODY consists of a series independent same-size logical units called
\emph{nuggets}. A nugget consists of one or more contiguous physical drive
blocks. Each nugget is coupled with metadata in the HEAD indicating which cipher
was used to encrypt the nugget along with any additional ciphertext output; the
latter allows us to treat any non-length-preserving ciphers as if they were
length-preserving. 

SwitchCrypt uses the Keycount Store and Transaction Journal
components along with our nugget layout to 1) track, detect, and handle
overwrites, 2) limit the maximum length of any plaintext input to ciphers, thus
amortizing the overhead incurred during encryption, and 3) independently and
efficiently switch the cipher used to encrypt individual nuggets.

StrongBox.


Dickens et al. showed how to make nugget-based drive organization secure using a
single stream cipher, ChaCha20, to handle overwrites, prevent rollback attacks,
and limit plaintext length~\cite{StrongBox}. 


However, they did not envision the
utility in trading off between concerns at the filesystem or device-mapper
level, dynamic cipher switching, or protecting against attacks on data ``in
motion;'' the remainder of this section details the novel components that enable
this functionality. Specifically: how we quantify the properties traded off
between configurations (\cref{subsec:quantify}), the Generic Stream Cipher
Interface and Per-Nugget Metadata components (\cref{subsec:interface}) which
decouple cipher implementations from the encryption process, and our Cipher
Switching Strategy implementations (\cref{subsec:strategies}) used to
efficiently encrypt nuggets with different ciphers.



% ===============================================
\subsection{????????????????}



% why chacha better than AES-XTS
\hsg{what is the purpose of this paragraph? again just to show we need to switch?
I moved this from an earlier section}
To truly address the security concern requires a cipher with an additional
security property: \emph{ciphertext randomization}. Without ciphertext
randomization, an attacker can map plaintexts to their ciphertext counterparts
during snapshot comparison, especially if they can predict what might be written
to certain drive regions. However, with ciphertext randomization, a cipher will
output a different ``random'' ciphertext even when given the same key, nonce,
and plaintext; this means, even after a forced rollback of system state and/or
legitimate restoration from a backup, comparing future writes is no longer
violates confidentiality because each snapshot will always consist of different
ciphertext regardless of the plaintext being encrypted or the state of the
drive. Using Freestyle~\cite{Freestyle}, a ChaCha20-based stream cipher that
supports ciphertext randomization, we can guarantee data confidentiality in this
way. So, we switch from StrongBox to an encryption driver that supports
Freestyle.



% FreeStyle more energy-constrainted, end to end (can be removed)
We revisit the motivating example from earlier in this work, where we're using
Freestyle to ensure secure backups in an energy-constrained environment.
Initially, I/O requests come down from the LFS and are received by the
cryptographic driver, which divides the request based on which nuggets it
touches. For each nugget, the per-nugget metadata is consulted to determine with
which cipher the nugget is encrypted. If it is encrypted with the active cipher
configuration (Freestyle), which must be true if we have not initiated a cipher
switch, the write is handled similarly to prior work: encrypted data is read in
from the drive, the merkle tree and monotonic counter are consulted to ensure
the integrity of encrypted data, the transaction journal is consulted during
write operations so that overwrites are handled and pad reuse violations are
avoided, and then the keycount store is consulted to derive the nugget's unique
encryption key from some master secret. Finally, using the Generic Stream Cipher
Interface, we call out to the Freestyle, allowing SwitchCrypt to
encrypts/decrypts the nugget's contents and commit any updates back to storage.
All the while, the drive's Freestyle-encrypted contents are being uploaded up to
our enterprise backup service every so often.

% can be removed
\hsg{from putting it all together}
When the device enters ``battery saver'' mode, drive backups are paused, the
energy monitoring software downclocks the CPU, and the OS signals to SwitchCrypt
that a more energy-efficient cipher (ChaCha20) should be used until we return to
a non-curtailed energy budget. SwitchCrypt sets ChaCha20 as the active cipher
configuration. Now, when the cryptographic driver divides I/O requests into each
affected nugget, the per-nugget metadata shows SwitchCrypt that each nugget is
encrypted using a cipher that is not the active configuration. This triggers the
re-ciphering code path. Since we are using the Forward switching strategy in
this example, nugget data is immediately decrypted by calling out to the
inactive configuration through the Generic Stream Cipher Interface, after which
the nugget is re-ciphered by calling out to the active configuration. Finally,
the cryptographic driver manages encrypting/decrypting data and updating the
merkle tree and monotonic counter, transaction journal, and keycount store as
the I/O operation and related metadata is committed to the drive afterwards.

