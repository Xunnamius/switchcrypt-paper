

\subsection{\sysA: Cipher Switching Models} 
\label{subsec:strategies}


% when and where
Just like typical storage devices, at any moment, there is only {\em one active} cipher
configuration (henceforth ``active configuration'').  However, with \sysA, we
provide a small temporal and spatial flexibility that allows movement
from one configuration point to another or even settle on optimal
configurations wholly unachievable with prior work.  When a cipher switch
is triggered, a different configuration becomes the active configuration,
and ``rechipering'' must be done --- using the just-inactived
configuration to decrypt a nugget's contents and using the active
configuration to re-cipher it.

% challenge
The challenge here is to accomplish this while minimizing overhead.  A
naive approach would switch every nugget in the device to the active
configuration immediately, but the latency and energy cost would be
unacceptable.  Hence, a more strategic approach is to provide different
switching models that allow higher-level policies to choose; for example,
depending on the use case, it may make the most sense to re-cipher a
nugget immediately, or eventually, or to maintain several areas of
differently-ciphered nuggets concurrently.  The different models allow for
nuggets to be re-ciphered in a variety of cases with minimal impact on
performance and battery life and without compromising security.  We
introduce three switching strategies: temporal, mirrored, and selective.
The first one forms a temporal switching while the latter two form a
spatial switching, as explained below and summarized in Table
\ref{tab-switch1}.


\input{tab-switch1}


\hsg{If I explain things wrong here, go ahead fix it. This is
based on my best understanding of our conversation.
Also, discuss with Hank if we should just name ``Forward''
with ``Temporal''.}

% ---------------------------------- forward switching

\mysub{Forward switching.}  The first type of cipher switching we support
is for the battery-life example where we want to switch from cipher
``\cone'', a highly-secure, energy-expensive cipher to cipher ``\ctwo,''
less-secure but more energy-efficient one.  This mode can be enabled with
a battery-saving mode (the higher-level policy) supported by the OS.

Table \ref{tab-switch1} summarizes what happens during the switch.  For new
incoming writes, the data will be ciphered with \ctwo.  Later on, when the
temporal switching ends, the data will remain ciphered with \ctwo
\hsg{correct?}.  The reason we don't recipher it back to \cone in the future
is that the files might be just a temporary file (\eg, movie download)
that is only read once.  However, if the data is read again in the future
when \cone is active again (\eg, for backing up to the cloud), the data will
then reciphered to \cone.
%
For read operations, if the existing data (ciphered with \cone) is read
during the switch, the data will be reciphered to \ctwo.  The reason behind
this is that reciphering to \ctwo is not expensive, and better to be done on
demand on the first read (during the switching) than later. 
%
In general, forward switching limits the performance impact of cipher
switching to individual nuggets being accessed.  The data at rest
(ciphered with \cone) that is never accessed during the switch remains in
its original state.



% variants
We note that there can be variants to the forward switching mode. The
above concept favors performance.  Another variant that can be support
that favors stronger security can be done this way: For writes, the moment
the switch back from \ctwo to \cone happens, the new data that was ciphered
with \ctwo is quickly ciphered to \cone.  To do this, we need to do more
recording, while the one we proposed above can be done on demand (when the
data is read in the future).
%
Another variant for the read operations can also be done as follows: the
data will {\em not} be reciphered on the first read.  The intuition is
that forward switching only happens temporarily (while the battery is
low), hence data being read might only be read once and stay in the
memory.  However, if the data is read the second time (during the temporal
period), the data is reciphered to \ctwo.
%
These and other possible variants can be left for future work.  So far, we
find our version of forward switching suits a common battery-life
scenario.




% --------------------------------------------------------------------

\mysub{Mirrored Switching.}  Next, we consider a different scenario where
``\cone'' is a recently-attacked and vulnerable encryption and ``\ctwo''
is a newly recommended cipher that's just been added to \sys's latest
kernel/module upgrade.  Let us imagine a server-side storage operator who wants to switch
from \cone to \ctwo without any server downtime.  To achieve this, \sys
since the beginning will partition the drive into 2 regions.  That is, to
support a full-drive cipher switch (supportec by the block layer and
without application/file system modification), we must pay the space cost
to anticipate such a switch in the future.  In this mode, we must add the
``migration'' period to reflect the transition window from \cone to \ctwo.

\hsg{I kind of change a bit how this mode should perform.  To me the
  previous method -- that partitions the device with C regions, it's a
  showstopper.  Imagine if you support C=10, are you saying that now we
  lose 90\% of the space for user data, and we keep them all
  mirroring(??).  That's a no no.  Also the case study here is about
  switching to a better cipher; so you cannot anticipate way before what
  kind of new cipher you'll transition into.  Also, talk to Hank if
  another name like ``Full/Migration/??'' Switching is a better one--
  because we're only mirroring during the migration.}

During the migration, as summarized in Table \ref{tab-switch1}, all write
operations that hit the \cone's region will be mirrored to the \ctwo's
region.  At the same time, the data in \cone's region is reciphered
incrementally to \ctwo's region.  Still during the migration, read
operations will be served by the original state (\cone's region) until the
full switch happens.  This is essentially similar to VM migration
\cite{google-live-vm-migration-nsdi}.  After the whole migration
completes, to fully secure-erase the previous region, one can use a
mechanism such as SSD Instant Secure Erase~\cite{ISE1,ISE2,ISE3}, thus
quickly and securely converging the drive to a single configuration
without losing any data or suffering the egregious performance or battery
penalty that comes with re-ciphering every nugget.

% ------------------------------------------------------------------------------

\mysub{Selective Switching.} 


\hsg{I have a hard time reading this, considering that we want to map the case study
of select files that we encrypt differently, \eg, encrypt legal files
in a more secure eway.  I think that case study doesn't really match selective switching,
and actually I'm lost on the best example for selective switching.
The reason is that if we want to say: we allow selective switching by allowing certain
files to be configured different ways, then it means we should allow multiple
configurations to be active at the same time. 
Now we could still have only one configuration that is active, but what that means is that
while I read the legal files, reading other files must be queued inside the \sys layer, because
\sys only has one active  configuration.  So this will reduce the performance.
If we want to make a scenario like this, we need to know why it is fundamentally impossible/hard
to allow multiple cipher configurations to be active at the same time. }


\hsg{also, need to talk to Bernard, whether dividing up the partitions is really fundemental
because of the way metadata/transcation journal is managed???}

When SwitchCrypt is initialized with the
Selective strategy, the drive is partitioned into $C$ regions where $C$
represents the total number of available ciphers in the system; each regions'
nuggets are encrypted by each of the $C$ ciphers respectively. For instance,
were SwitchCrypt initialized using two ciphers ($C = 2$), the drive would be
partitioned in half; all nuggets in the first region would be encrypted with the
first cipher while all nuggets in the second would be encrypted with the other.

When using this strategy, the active cipher determines which partition we
``select'' for I/O operations. Hence, unlike the Forward strategy, which
schedules individual nuggets to be re-ciphered at some point in time after the
active configuration is switched, the Selective strategy allows the wider system
to indicate \emph{where} on the drive a read or write operation should occur. In
this way, the Selective strategy represents a form of spatial cipher switching
where different regions of the drive can store differently-ciphered nuggets
independently and concurrently. A user could take advantage of this to, for
instance, set up regions with different security properties and performance
characteristics, managing them as distinct virtual drives or transparently
reading/writing bytes to different security regions on the same drive.


