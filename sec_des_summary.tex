\subsection{Putting It All Together}\label{subsec:des-summary}

Here we discuss other details surrounding our three main contributions.

% ---------------------------------- metadata

\mysub{Secure metadata management.} The focus of this work is to implement
mechanisms and policies to perform flexible switching of cipher configurations.
These configurations are built atop an existing block-level encryption module
(or ``encryption driver'') that manages our data structures and provides
cryptographic support. There were several open source choices for an encryption
driver: Linux's encryption device mapper~\cite{dmcrypt,DmC-Android},
encryption-ready F2FS filesystem~\cite{F2FS}, or StrongBox~\cite{StrongBox}. We
decided to build \sys atop StrongBox because it already implements stream cipher
based FDE and employs a nugget-based drive layout.

\sys depends on the data structure management provided by StrongBox, such as its
{\em transaction} and {\em rekeying journals} to avoid overwrite
violations~\cite{StrongBox}, {\em Merkle tree} to avoid rollback and related
attacks~\cite{StrongBox}, {\em monotonic counter} on a trusted hardware to
prevent rollbacks, {\em keycount store} to derive unique encryption keys, and
{\em per-nugget metadata} to store cipher-specific metadata (useful for
ciphertext-expanding ciphers). Every \sys volume also has a ``head'' area that
stores implementation-wide data like the master encryption key or which cipher
is currently active.

While we reuse some StrongBox components, all of these are tightly integrated to
with a special ChaCha20 implementation. We had to untangle this, hence the \sysB
contribution, where we expose structured interfaces allowing cipher implementors
to easily build crypts from any off-the-shelf stream cipher implementation.
Specifically, of the six StrongBox components listed above, only the keycount
store and monotonic counter can be reused as is; the others were rewritten to
support \sysA and \sysB.

% ---------------------------------- security

\mysub{Threat model under switching.} In terms of {\em confidentiality}, an
adversary should not be able to reveal any information about encrypted plaintext
without the proper key. As with prior works, encryption is achieved via a binary
additive approach: cipher output (keystream) is combined with plaintext nugget
contents using XOR, with metadata to track writes and ensure that pad reuse
never occurs during overwrites and that the system can recover from crashes into
a secure state.

In terms of {\em data integrity}, an adversary should not be able to tamper with
ciphertext and it go unnoticed. Nugget integrity is tracked by StrongBox's
in-memory Merkle tree~\cite{StrongBox}.

Switching strategies add an additional security concern not addressed by prior
work: even if we initiate a ``cipher switch,'' there may still be data on the
drive that was encrypted with an inactive configuration. Is this a problem? For
the Forward model, this implies data may at any time be encrypted using the
``least desirable cipher''. For the Mirrored and Selective strategies, the drive
is partitioned into regions where nuggets are guaranteed to be encrypted with
each cipher, including the ``least desirable cipher''. However, in terms of
confidentiality, the confidentiality guarantee of \sys can be reduced to the
individual confidentiality guarantees of the available ciphers used to encrypt
nuggets.

% ---------------------------------- integration
\mysub{Higher-level integration.} \sys expects a higher-level integration/policy
that communicates what kind of switching should be performed and when. An
example is the battery saver scenario, where the OS battery saver application is
expected to notify \sys when to move to an energy-efficient crypt versus a
backup-ready crypt using Forward switching. See \cref*{sec:usecases} for more
integrations.

% ---------------------------------- generality
\mysub{Generality.} \sys can be seen as a drop-in replacement for the popular
Linux dm-crypt layer (encryption driver). For performance reasons, like
StrongBox, \sys recommends a Log-structured File System (LFS) such as F2FS,
YAFFS, or LogFS, which are commonly used for flash devices. The reason for this
is that supporting streaming ciphers is more efficient in storage systems with
no in-place updates~\cite{StrongBox}. Though \sys is a software solution, the
same LFS-based logic can be adopted by hardware like flash devices. For example,
the LFS-like ``no in-place updates'' nature of Flash Transition Layers (FTL)
would allow heterogeneous FDE implementations be performant at the device
controller level, allowing the use of other popular in-place update file systems
such as ext4, btrfs, and xfs.
