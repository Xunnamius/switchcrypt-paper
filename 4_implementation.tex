\section{Implementation}

Our SwitchBox implementation consists of 9,491 lines of C code; our test suite
consists of 6,077 lines of C code. All together, our solution is comprised of
15,568 lines of C code.

SwitchBox uses OpenSSL version 1.1.0h and LibSodium version 1.0.12 for its
AES-XTS and AES-CTR implementations. Open source ARM NEON optimized
implementations of ChaCha are provided by Floodyberry~\cite{Floodyberry}. The
Freestyle cipher reference implementation is from the original Freestyle
paper~\cite{Freestyle}. The eSTREAM Profile 1 cipher implementations are from
the open source libestream cryptographic library~\cite{libestream} by Lucas
Clemente Vella. As with the original StrongBox construction, the Merkle Tree
implementation is from the Secure Block Device~\cite{SBD}. SwitchBox
implementation is publicly available open-source\footnote{\SystemURI}.

We use the BUSE~\cite{BUSE} virtual block device as our device controller.
BUSE is a thin (200 LoC) wrapper around the standard Linux Network Block Device
(NBD). BUSE allows an operating system to transact block I/O requests to and
from virtual block devices exposed via domain socket.

For experimental purposes, our implementation makes the choice of ciphers
binary: either the system wants SwitchBox to access the backing store using the
primary cipher or the secondary cipher. However, there is no technical
limitation preventing various different nuggets encrypted with three, four, or
more unique ciphers from co-existing on the backing store.

For both spatial and temporal cipher switching, when SwitchBox should be using
the primary cipher or the secondary cipher to interact with the backing store,
this intent is communicated via POSIX message queue in our implementation. It is
not a requirement of SwitchBox that a POSIX message queue be used over any other
method of IPC so long as SwitchBox is notified asynchronously when the wider
system desires one cipher be active over the other.

A production-ready implementation would be greatly simplified by adding an
``intent'' parameter to the POSIX \textit{read()} and \textit{write()} system
calls, allowing SwitchBox to more exactly map individual I/O operations to
specific areas of the backing store when spatially switching. This is especially
important when considering the selective switching strategy; a production-ready
implementation supporting selective switching would need to differentiate
between metadata operations belonging to the filesystem (should be mirrored
across all partitions) and actual end-user data (should be selectively read from
and written to nuggets in specific partitions).

\subsection{Backing Store Initialization}

To operate securely, SwitchBox must be seeded with random data initially rather
than have the backing store consist of all zeroes. This is a one-time cost paid
during initialization and has no tangible effect on performance.

If nuggets are not seeded with random data initially, any write operation into
an "empty" nugget might leak information or constitute an overwrite when the
predictable state of the backing store (\ie{initialized to all zeroes}) leads to
an overwrite-style condition.
