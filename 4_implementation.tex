\section{Implementation}\label{sec:implementation}

Our SwitchCrypt implementation consists of 9,491 lines of C code; our test suite
consists of 6,077 lines of C code. All together, our solution is comprised of
15,568 lines of C code. Our implementation is also publicly available
open-source\footnote{\SystemURI}.

SwitchCrypt uses OpenSSL version 1.1.0h and LibSodium version 1.0.12 for its
AES-XTS and AES-CTR implementations. Open source ARM NEON optimized
implementations of ChaCha are provided by Floodyberry~\cite{Floodyberry}. The
Freestyle cipher reference implementation is from the original Freestyle
paper~\cite{Freestyle}. The eSTREAM Profile 1 cipher implementations are from
the open source libestream cryptographic library~\cite{libestream} by Lucas
Clemente Vella. The Merkle Tree implementation is from the Secure Block
Device~\cite{SBD}.

We implement SwitchCrypt on top of the BUSE~\cite{BUSE} virtual block device,
using it as our mock device controller. BUSE is a thin (200 LoC) wrapper around
the standard Linux Network Block Device (NBD). BUSE allows an operating system
to transact block I/O requests to and from virtual block devices exposed via
domain socket.

For experimental purposes, our implementation makes the choice of ciphers
binary: either the system wants SwitchCrypt to access the backing store using the
primary cipher or the secondary cipher. However, there is no technical
limitation preventing various different nuggets encrypted with three, four, or
more unique ciphers.

Cipher switching is a cross-cutting concern---for instance, the desire to switch
ciphers could come from an unrelated process in user space, so we use POSIX
message queues in our implementation.

A production-ready implementation would be greatly simplified by adding an
``intent'' parameter to the POSIX \textit{read()} and \textit{write()} system
calls, allowing SwitchCrypt to more exactly map individual I/O operations to
specific areas of the backing store when spatially switching. We simulate this
with IPC. \PUNT{This is especially important when considering the selective
switching strategy; a production-ready implementation supporting selective
switching would need to differentiate between metadata operations belonging to
the filesystem (should be mirrored across all partitions) and actual end-user
data (should be selectively read from and written to nuggets in specific
partitions).}

Further, to operate securely, SwitchCrypt must be seeded with random data
initially rather than have the backing store consist of all zeroes. This is a
one-time cost paid during initialization and has no tangible effect on
performance.

\subsection{Freestyle Configurations}

As Freestyle is highly configurable, we implement it in three different
configurations: a ``fast'' mode with parameters
\\\texttt{FreestyleFast($R_{min}$=$8$, $R_{max}$=$20$, $H_I$=$4$, $I_C$=$8$)}, a
``balanced'' mode with parameters \texttt{FreestyleBalanced($R_{min}$=$12$,
$R_{max}$=$28$, $H_I$=$2$, $I_C$=$10$)}, and a ``secure'' mode with parameters
\texttt{FreestyleSecure($R_{min}$=$20$, $R_{max}$=$36$, $H_I$=$1$,
$I_C$=$12$)} per the recommendations of the Freestyle authors~\cite{Freestyle}.

Thanks to Freestyle's output randomization, we can skip the overhead of
tracking, detecting, and handling overwrites.
