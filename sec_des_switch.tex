\subsection{\sysA: Cipher Switching Models}\label{subsec:des-switch}

% About: when and where
Just like typical storage devices, at any moment, there is only {\em one active}
cipher configuration (henceforth ``active configuration''). However, with \sysA,
we provide a small temporal and spatial flexibility that allows movement from
one configuration point to another or even settle on optimal configurations
wholly unachievable with prior work. When a cipher switch is triggered, a
different configuration becomes the active configuration, and ``re-ciphering''
must be done --- using the just-deactivated configuration to decrypt a nugget's
contents and using the active configuration to re-cipher it.

% About: challenge
The challenge here is to accomplish this while minimizing overhead. A naive
approach would switch every nugget in the device to the active configuration
immediately, but the latency and energy cost would be unacceptable. Hence, a
more strategic approach is to provide different switching models that allow
higher-level policies to choose; for example, depending on the use case, it may
make the most sense to re-cipher a nugget immediately, or eventually, or to
maintain several areas of differently-ciphered nuggets concurrently. The
different models allow for nuggets to be re-ciphered in a variety of cases with
minimal impact on performance and battery life and without compromising
security. We introduce three switching strategies: temporal, mirrored, and
selective. The first one forms a temporal switching while the latter two form a
spatial switching, as explained below and summarized in Table \cref{tbl:switch}.

\input{graphics/tbl-switch}

% ---------------------------------- forward switching

\mysub{Forward switching.} The first type of cipher switching we support is for
the battery-life example where we want to switch from cipher ``\cone'', a
highly-secure, energy-expensive cipher to cipher ``\ctwo,'' less-secure but more
energy-efficient one. This mode can be enabled with a battery-saving mode (the
higher-level policy) supported by the OS.

Table \cref{tbl:switch} summarizes what happens during the switch. For new
incoming writes, the data will be ciphered with \ctwo. Later on, when the
temporal switching ends, the data will remain ciphered with \ctwo
\hsg{correct?}. The reason we don't re-cipher it back to \cone in the future is
that the files might be just a temporary file (\eg movie download) that is only
read once. However, if the data is read again in the future when \cone is active
again (\eg for backing up to the cloud), the data will then re-ciphered to
\cone. For read operations, if the existing data (ciphered with \cone) is read
during the switch, the data will be re-ciphered to \ctwo. The reason behind this
is that re-ciphering to \ctwo is not expensive, and better to be done on demand
on the first read (during the switching) than later. In general, forward
switching limits the performance impact of cipher switching to individual
nuggets being accessed. The data at rest (ciphered with \cone) that is never
accessed during the switch remains in its original state.

% About: variants
We note that there can be variants to the forward switching mode. The above
concept favors performance. Another variant that can be support that favors
stronger security can be done this way: For writes, the moment the switch back
from \ctwo to \cone happens, the new data that was ciphered with \ctwo is
quickly ciphered to \cone. To do this, we need to do more recording, while the
one we proposed above can be done on demand (when the data is read in the
future). Another variant for the read operations can also be done as follows:
the data will {\em not} be re-ciphered on the first read. The intuition is that
forward switching only happens temporarily (while the battery is low), hence
data being read might only be read once and stay in the memory. However, if the
data is read the second time (during the temporal period), the data is
re-ciphered to \ctwo. These and other possible variants can be left for future
work. So far, we find our version of forward switching suits a common
battery-life scenario.


% ---------------------------------- mirrored switching

\mysub{Mirrored Switching.} Next, we consider a different scenario where
``\cone'' is a recently-attacked and vulnerable encryption and ``\ctwo'' is a
newly recommended cipher that's just been added to \sys's latest kernel/module
upgrade. Let us imagine a server-side storage operator who wants to switch from
\cone to \ctwo without any server downtime. To achieve this, \sys since the
beginning will partition the drive into 2 regions. That is, to support a
full-drive cipher switch (supported by the block layer and without
application/file system modification), we must pay the space cost to anticipate
such a switch in the future. In this mode, we must add the ``migration'' period
to reflect the transition window from \cone to \ctwo.

During the migration, as summarized in Table \cref{tbl:switch}, all write
operations that hit the \cone's region will be mirrored to the \ctwo's region.
At the same time, the data in \cone's region is re-ciphered incrementally to
\ctwo's region. Still during the migration, read operations will be served by
the original state (\cone's region) until the full switch happens. This is
essentially similar to VM migration \cite{google-live-vm-migration-nsdi}. After
the whole migration completes, to fully secure-erase the previous region, one
can use a mechanism such as SSD Instant/Secure Erase~\cite{ISE1,ISE2,ISE3}, thus
quickly and securely converging the drive to a single configuration without
losing any data or suffering the egregious performance or battery penalty that
comes with re-ciphering every nugget.

We would like to note that it is fundamentally hard to have two cipher
configurations enabled on the same drive. There are two reasons. First,
..\hsg{anything about data structures, such as the extra space of teh nugget?
Let's put more technical matters here, so reviewers can appreciate why we have
to crude partition the drive like this.} Second, after the migration the
previous region might need to be securely erased; here, not overlapping the two
regions would make things more straightforward for erase secure. We are not
aware of any solution that allow multiple ciphers activated per drive volume.


% ---------------------------------- selective switching

\mysub{Selective Switching.} Storing classified materials, corporate secrets,
etc. require the highest level of discretion, yet sensitive information like
this can appear within a (much) larger amount of data that we value less.

For example, perhaps banking transaction information is littered throughout a
PDF; perhaps passwords and other sensitive information exists within several
much larger files. Using prior techniques, either all the data would be stored
with high overhead, the critical data would be stored without the mandated
cipher type, or the data would have to be split among separate files requiring
potentially complex and error-prone management schemes. \sys allows us to
sidestep these issues.

\hsg{also, need to talk to Bernard, whether dividing up the partitions is really
fundemental because of the way metadata/transcation journal is managed???}

When \sys is initialized with the Selective strategy, the drive is partitioned
into $C$ regions where $C$ represents the total number of available ciphers in
the system; each regions' nuggets are encrypted by each of the $C$ ciphers
respectively. For instance, were \sys initialized using two ciphers ($C = 2$),
the drive would be partitioned in half; all nuggets in the first region would be
encrypted with the first cipher while all nuggets in the second would be
encrypted with the other.

When using this strategy, the active cipher determines which partition we
``select'' for I/O operations. Hence, unlike the Forward strategy, which
schedules individual nuggets to be re-ciphered at some point in time after the
active configuration is switched, the Selective strategy allows the wider system
to indicate \emph{where} on the drive a read or write operation should occur. In
this way, the Selective strategy represents a form of spatial cipher switching
where different regions of the drive can store differently-ciphered nuggets
independently and concurrently. A user could take advantage of this to, for
instance, set up regions with different security properties and performance
characteristics, managing them as distinct virtual drives or transparently
reading/writing bytes to different security regions on the same drive. IO
Differentiation is not new.
