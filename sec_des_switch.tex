\subsection{\sysA: Cipher Switching Models}\label{subsec:des-switch}

% About: when and where
Though not a technical limitation, it is helpful to think of \sys as having a
single {\em active cipher configuration} among several available. With \sysA,
our storage system has the flexibility to switch from one cipher configuration
to another, or even employ multiple configurations in a way unachievable with
prior work. When a cipher switch is triggered, a different configuration becomes
the active configuration, and ``re-ciphering'' must be done, \ie using the
deactivated configuration to decrypt a nugget's contents and using the active
configuration to re-cipher it.

% About: challenge
The challenge here is to accomplish re-ciphering while minimizing overhead. A
naive approach would switch every nugget to the active configuration
immediately, but the latency and energy cost would be unacceptable. Hence, a
more strategic approach is is necessary. For example, depending on the use case,
it may make the most sense to re-cipher a nugget immediately, or eventually, or
to maintain several areas of differently-ciphered nuggets concurrently. Our
models allow for nuggets to be re-ciphered in a variety of cases with minimal
impact on performance and battery life and without compromising security; they
are: Forward, Mirrored, and Selective. The Forward model represents a form of
temporal switching while the Mirrored and Selective models represent forms of
spatial switching as explained below and summarized in \cref{tbl:switch}.

\input{graphics/tbl-switch}

% ---------------------------------- Forward switching

\mysub{Forward switching.} In the case of the battery saver mode example, we
want to switch from cipher ``\cone'', a highly-secure, energy-expensive cipher
to cipher ``\ctwo,'' a less-secure but more energy-efficient cipher. However,
for efficiency, {\em we only switch nuggets on demand}, \ie that are touched
during I/O. This switching model would be enabled as part of a higher-level
policy (\ie battery saver mode) enacted by the OS or user.

Table \cref{tbl:switch} summarizes what happens immediately after the active
cipher is switched to \ctwo. For nugget-sized writes, new data is ciphered with
\ctwo and committed as normal. For intra-nugget writes, the nugget is first
decrypted using \cone and then re-ciphered using \ctwo with the new data
included. The new nugget is then committed as normal. Re-ciphering only occurs
when necessary; once a nugget is ciphered with \ctwo, no further switching is
required. For reads, we consider the first, second, and nth read accesses. On
the first read, the nugget is decrypted using \cone and the data returned. If
that same nugget is read a second time, it is re-ciphered with \ctwo before the
data is returned. On subsequent reads, the nugget is decrypted with \ctwo and
read as normal.

Later, when battery saver mode is turned off and \cone becomes the active cipher
again, nuggets are not automatically re-ciphered as, again, that would be
inefficient. Nuggets will be re-ciphered on demand using the converse of the
process described above. In general, Forward switching limits the performance
and battery impact of cipher switching to the individual nuggets being accessed.
The data at rest (ciphered with \cone) that is never accessed during the switch
remains in its original state.

% About: variants
We note that there can be variants to the Forward switching model. For instance,
a variation on read operations: we consider the first, second, and nth read
accesses distinctly. On the first read, the nugget is decrypted using \cone and
the data returned. Only if that same nugget is read a second time is it
re-ciphered with \ctwo before the data is returned. On subsequent reads, the
nugget is decrypted with \ctwo and read as normal. The intuition is that Forward
switching only happens temporarily (\eg while the battery is low), hence data
being read might only be read once and stay in memory. However, if the nugget is
read the second time, then the data is re-ciphered to \ctwo. This and other
possible variants are left for future work. So far, we find our version of
Forward switching suits a common battery-saving scenario.


% ---------------------------------- Mirrored switching

\mysub{Mirrored switching.} Next, we consider a different scenario where
``\cone'' is a cipher that has been superseded by ``\ctwo'', a newly recommended
cipher that has just been added to \sys's latest kernel/module upgrade. Let us
imagine a datacenter storage operator who wants to upgrade from \cone to \ctwo
without any service interruptions. Anticipating this, our operator partitions
available storage into two regions. That is, to support a full-drive cipher
switch supported by the block layer and without application/file system
modification, we must pay the space cost to anticipate such a switch.

During the migration, as summarized in Table \cref{tbl:switch}, all write
operations that hit \cone's region will be mirrored to \ctwo's region.
Meanwhile, in the background, the data in \cone's region is incrementally
re-ciphered and written to \ctwo's region. Until the migration is complete, read
operations will be served by \cone's region. This is very similar to VM live
migration \cite{live-vm-migration}. After the migration completes, one can use a
mechanism such as SSD Instant/Secure Erase~\cite{ISE1,ISE2,ISE3} to securely
erase the previous storage region's data.

In general, Mirrored switching allows us to converge storage state to a single
cipher configuration without losing any data, suffering outages or downtime, or
violating any critical service-level agreements. We note that, after the
migration, the previous region's data needs to be securely erased to complete
the upgrade; here, not overlapping the two regions makes Instant/Secure Erase
straightforward~\cite{ISE1,ISE2}.


% ---------------------------------- Selective switching

\mysub{Selective switching.} Storing classified materials, corporate secrets,
etc. require the highest level of discretion, yet sensitive information like
this can appear within a (much) larger amount of data that we value less. For
example, perhaps banking transaction information is littered throughout a PDF;
perhaps passwords and other sensitive information exists within several much
larger files. Using prior techniques, either all the data would be stored with
high overhead, the critical data would be stored without the mandated cipher
type, or the data would have to be split among separate files requiring
potentially complex and error-prone management schemes. \sys allows us to
sidestep these issues.

When \sys is initialized with the Selective strategy, the drive is partitioned
into $C$ regions where $C$ represents the total number of available ciphers in
the system; each regions' nuggets are encrypted by each of the $C$ ciphers
respectively. For instance, were \sys initialized using two ciphers ($C = 2$),
the drive would be partitioned in half; all nuggets in the first region would be
encrypted with the first cipher while all nuggets in the second would be
encrypted with the other.

When using this strategy, the active cipher determines which partition we
``select'' for I/O operations. Hence, unlike the Forward strategy, which
schedules individual nuggets to be re-ciphered at some point in time after the
active configuration is switched, the Selective strategy allows the wider system
to indicate \emph{where} on the drive a read or write operation should occur. In
this way, the Selective strategy represents a form of spatial cipher switching
where different regions of the drive can store differently-ciphered nuggets
independently and concurrently. A user could take advantage of this to, for
instance, set up regions with different security properties and performance
characteristics, managing them as distinct virtual drives or transparently
reading/writing bytes to different security regions on the same drive. IO
Differentiation is not new.
