\subsection{\sysB: Cipher Wrapper Interfaces}\label{subsec:des-crypts}

% About: challenge, input, output
One of the goals of \sys is that we might use any stream cipher regardless of
its implementation details. However, allowing these ciphers to co-exist in the
same volume is challenging since there are many cipher implementations
that we might use, each with unique input requirements and output
considerations. For instance, Salsa and Chacha implementations require a certain
IV and key size and handle plaintext input through successive invocations of a
single state update function~\cite{Floodyberry}. Using OpenSSL's AES
implementation in CTR mode requires manually tracking the counter state and
individual ciphertext blocks are retrieved though corresponding function
invocations~\cite{OpenSSL}. Freestyle's reference implementation requires we
calculate the extra space necessary per nugget (due to ciphertext expansion)
along with configuration-dependent minimum and maximum rounds-per-block, hash
interval, and pepper bits~\cite{Freestyle}. HC-128 and other ciphers have
similarly disparate requirements.

Further, unlike prior work, \sys must encrypt and decrypt arbitrary
nuggets {\em with any of these ciphers} at any moment with low
overhead and without tight coupling to any specific implementation
detail. Hence, we must abstract away these input and output
requirements by decoupling cipher implementations from the core
encryption process. We present \sysB, a collection of interfaces that
allow implementors to write light (<100 LOC) wrapper functions around
cipher implementations without modifications to third-party code; we
call these wrapped ciphers {\em crypts}. Crypts present \sys with a
uniform encryption and decryption interface for each cipher, enabling
normally incompatible ciphers to encrypt and decrypt arbitrary nuggets
and thus coexist in our heterogeneous FDE system.

% About: single enc/dec model, the OS has one way to talk to \sys The
ability for disparate cipher implementations to co-exist in this way
forms the foundation for \sys's ability to switch the system between
different cipher configurations efficiently and effectively. To
facilitate this, \sysB presents the cryptographic driver with a single
uniform encryption/decryption model. \sys receives I/Os from the
operating system at the block device level like any other
device-mapper. These I/Os come in the form of either reads or
writes. When a read is received, the OS hands \sys an offset and a
length and expects a response with plaintext of that specific length
starting at that specific offset taken from the beginning of
storage. When a write is received, the OS hands \sys an offset, a
length, and a buffer of plaintext and expects that plaintext to be
encrypted and committed to storage such that the plaintext is later
retrievable given that same offset and length in a future read. Crypts
handle these I/Os by implementing either \texttt{xor\_interface} or
both \texttt{read\_interface} and \texttt{write\_interface}. \hank{I
got a little confused here.  The idea is that \sysB is a shim between
the OS and the encryption layer? If so, then I think just say that
explicitly.  The other thing that is confusing to me is that the text
says \sysB presents a single uniform encryption layer, but there are
obviously two different interfaces here. I think I know how that gets
resolved and what is really going on, but I am not sure and if I am
not sure, then reviewers will definitely not be sure. This part sort
of reads as if it is super-obvious to you and so you don't want to
bore your readers, but err on the side of boredom as you understand
this much better than your readers and you have had a long time to
figure it out, whereas they will have about an hour if we are lucky.
It might help to say explicitly who implements these interfaces and
who calls them. I realize that in this paper you (Bernard) implement
them and call them, but you are playing all roles so talk about what
it should look like if this system was widely deployed.}

% ---------------------------------- xor interface

{\bf \texttt{xor\_interface}} executes independently of \sys internals and
treats encryption and decryption as the same operation. Crypts receive an
integer offset $F$, an integer length $L$, a key buffer $K$ corresponding to the
current nugget, and an empty $L$-length XOR buffer. \sys expects the XOR buffer
to be populated with $L$ bytes of keystream output from some stream cipher
seeked to offset $F$ with respect to key $K$. The length of the key buffer will
always be exactly what the cipher implementation expects, alleviating the burden
of key management; similarly, the XOR buffer will be XOR-ed with the appropriate
portion of nugget contents automatically, alleviating the burden of drive access
and other tedious calculations.

% ---------------------------------- read/write interface

{\bf \texttt{read\_interface}} and {\bf \texttt{write\_interface}}, on the other
hand, treat encryption and decryption as distinct concerns.
\texttt{read\_interface} handles decryption and re-ciphering during reads.
\texttt{write\_interface} handles encryption and re-ciphering during writes.
Crypts receive full access to \sys internals, giving wrapper code deep hooks
into the encryption and decryption process and allowing implementers to bypass
parts of the nugget-based storage layout if necessary. This comes at the cost of
increased code complexity and potential performance implications, since \sys
must account for not having absolute control over its internal data structures
when using this crypt.

For this work we have implemented \numConfigs crypts using \numCiphers
ciphers---ChaCha, Freestyle, AES-CTR, AES-XTS, Rabbit, Sosemanuk,
HC-128---each in under 100 LOC (excluding the cipher algorithm
itself). \hank{Say which interfaces were used for which ciphers.  That
will make it all more real.}
