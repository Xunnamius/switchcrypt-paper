\section{Motivation}\label{sec:motivation}

\subsection{Example: Filesystem Reacts to ``Battery Saver''}

\PUNT{\begin{figure}[ht] \textbf{Linearity Between Baseline Cipher Latency and
Energy Use}\par\medskip
   \centering
   {\input{charts/linearity-latency-energy.tex}} \caption{Comparison of cipher
   configuration median sequential and random latency versus median total energy
   use per I/O operation size (4KB, 512KB, 5MB, 40MB) without switching. The
   relationship between latency and total energy use is linear for the cipher
   configurations we examine in this paper.}
  \label{fig:linearity-latency-energy}
\end{figure}}

Suppose we have an ARM-based ultra-low-voltage netbook provided to us by our
employer. As this is an enterprise device, our employer requires that 1) our
drive is fully encrypted at all times and 2) our encrypted data is constantly
backed up to an offsite system. The industry standard in full drive encryption
is AES-XTS, so we initialized our filesystem with it. Given these requirements,
three primary concerns present themselves.

First, it is well known that FDE using AES-XTS adds significant latency and
power overhead to I/O operations, especially on mobile and battery-constrained
devices~\cite{google-engadget, android-M-mobile-motivation,
android-M-mobile-motivation-2}. To keep our drive encrypted at all times with
AES-XTS means we must accept this hit to performance and battery life. Worse, if
our device does not support hardware accelerated AES, performance can be
degraded even further; I/O latency can be as high as 3-5x~\cite{StrongBox}.
Hardware accelerated AES is hardly ubiquitous, and the existence of myriad
devices that do not support it cannot simply be ignored, hence Google's
investment in Adiantum~\cite{Adiantum}.

Second, AES-XTS was designed to mitigate threats to drive data ``at rest,''
which implies an attacker cannot access snapshots of our encrypted data nor
manipulate that data without it being immediately obvious to us. With access to
multiple snapshots of a drive's AES-XTS-encrypted contents, an attacker can
passively glean information about the plaintext over time, possibly violating
data confidentiality~\cite{XEX, XTS}. Similarly, an attacker that can flip
encrypted bits without drawing our attention will corrupt any eventual
plaintext. Unfortunately, in real life, data rarely remains ``at rest'' in this
way. In our example, our employer requires we back up the contents of our drive
to some offsite backup service. This service will receive periodic snapshots of
the encrypted state of our drive, violating our invariant.

Third, our system is battery constrained, placing a cap on our energy budget
that can change at any moment.

To alleviate the performance concern, we can choose a stream cipher like
ChaCha20 rather than the AES-XTS block cipher. Using StrongBox, an encryption
driver built for ChaCha20-based FDE, we can achieve on average a 1.7x speedup
and a commensurate reduction in energy use~\cite{StrongBox}.

When it comes to the security concern, StrongBox solves the snapshot problem by
never writing data encrypted with the same key to the same location; generally,
this guarantees confidentiality even when snapshots are compared. StrongBox
solves the integrity problem by tracking drive state using a Merkle tree
construction along with trusted hardware like a TPM, ensuring data manipulations
cannot occur. Unfortunately, an attacker with sufficient permissions might
restore the drive state from one of these backups without our knowledge,
allowing an attacker to compare any new snapshots against the old ones and
potentially violate confidentiality.

To truly address this concern requires a cipher with an additional security
property: ciphertext randomization. Even after a rollback of drive state
occurred after restoring from a backup (or during an attack), using
Freestyle~\cite{Freestyle}, a ChaCha20-based stream cipher that supports
ciphertext randomization, we can guarantee data confidentiality regardless. So,
we switch to an encryption driver that supports Freestyle.

Unfortunately, like AES-XTS, Freestyle has significant overhead compared to the
original ChaCha20. In exchange for stronger security properties, Freestyle is up
to 1.6x slower than ChaCha20, uses more energy, has a higher initialization
cost, and expands the ciphertext which reduces total writeable drive
space~\cite{Freestyle}.

Further complicating matters is our final concern: a constrained energy budget.
Our example system is battery constrained. Even if we accepted trading off
performance, drive space, and energy for security in some situations, in other
situations, there may be a more optimal tradeoff possible. For example, when we
trigger ``battery saver'' mode, we expect our device to conserve as much energy
as possible.

It would be ideal if our device could pause backups and the encryption driver
could switch from the high security Freestyle configuration back to the high
performance energy-efficient ChaCha20 configuration when conserving energy is a
top priority, and then switch back to Freestyle when we connect to a charger and
backups are eventually resumed.

\subsection{Key Challenges}

The above is possible if---rather than restricting the system to a single
cipher---we could flexibly encrypt data with a range of ciphers and
cryptographic keys at the block level. To achieve this, we must address three
challenges. First, we must understand how to flexibly encrypt independent
storage units efficiently. This requires we \emph{decouple} cipher
implementations from the encryption. Second, we need to know when to
``re-cipher'' those units and where to store the output, ensuring acceptable
overhead. We accomplish this with our \emph{switching strategies}. Third, we
must reason about why to use one cipher over another. This requires we
\emph{quantify} the desirable security properties of different ciphers.

\textbf{Decoupling ciphers from encryption for mixed-cipher layouts.} To rapidly
switch ciphers for the drive, we require a \emph{generic cipher API} and
flexible drive layout. These requirements are challenging because, even with the
class of stream ciphers, we find vastly different input requirements, output
formats, and other barriers to presenting a single unified interface that can
work with our flexible drive layout. We achieve the required generality by
defining independent storage units we call \emph{nuggets}. We borrow this
terminology from prior work (see \cite{StrongBox}) to easily differentiate our
logical blocks (nuggets) from physical drive and other storage blocks. And since
they are independent, we can use our cipher API to select any cipher to encrypt
or decrypt any nugget at any point, answering the ``how'' of switching ciphers.

\textbf{Strategies to switch nugget ciphers with acceptable overhead.} To answer
``when'' to switch a nugget's cipher and to ``where'' we commit the output, we
implement a series of policies we call \textit{cipher switching strategies} that
leverage the generic cipher API and drive layout to selectively ``re-cipher''
groups of nuggets, whereby the key and the cipher used to encrypt/decrypt a
nugget are switched at runtime. These strategies allow us to navigate our
configuration tradeoff space and settle on optimal points unreachable with prior
work. The challenge here is to accomplish this while minimizing overhead.

\textbf{Quantifying ciphers with disparate security properties.} Finally, to
obtain a configuration space that we might reason about, it is necessary to
score certain security properties of stream ciphers. This is challenging since
different ciphers have a wide range of disparate security properties, including
ciphers that are not length-preserving in their output. To address this
challenge, we propose a method for quantitative cipher comparison in the FDE
context and use it to define our configuration space. These cipher
configurations, each with different strengths, answer ``why'' we might prefer
one over another.
