\section{Motivation}\label{sec:motivation}

\subsection{Background}

The standard approach to FDE, using the AES \emph{block cipher}, introduces
significant overhead during filesystem operation. It is well known that
authenticated encryption using \emph{stream ciphers} is faster than using
AES~\cite{StrongBox, AnotherPaper1, AnotherPaper2}. However, when used naively
in drive encryption, stream ciphers are widely known to be vulnerable to
``overwrite attacks'' like pad reuse and rollback~\cite{KatzLindell, StrongBox}.
To enable FDE using stream ciphers, prior work explores several approaches:

\begin{itemize}
   \item Use a non-deterministic CTR mode with specially designed cipher and
   filesystem (Freestyle~\cite{Freestyle}).
   \item Use a length-preserving ``tweakable super-pseudorandom permutation''
   construction with nonce-accepting stream cipher (Adiantum~\cite{Adiantum}).
   \item Use a stream cipher in a binary additive (XOR) mode leveraging metadata
   management and Log-structured File Systems' (LFS) overwrite-averse behavior
   to prevent overwrites (StrongBox~\cite{StrongBox}).
\end{itemize}

Though the tradeoffs and ideas explored in this paper can apply to any use of
stream ciphers in FDE using some binary additive operation, we focus on the
lattermost prior approach: stream cipher based (inflexible) FDE and metadata
layers that exploit LFS overwrite-averse behavior to achieve high-performance
encryption. Prior work in this area uses a single stream cipher exclusively in a
secure binary additive mode (XOR) to encrypt and decrypt data at rest. Threats
like pad reuse~\cite{KatzLindell} (\ie{two-time pad}) and rollback attacks---all
caused by overwrites---are mitigated through some form of \emph{re-keying},
where groups of contiguous storage blocks are decrypted with the old key and
encrypted again with a new key when an overwrite is detected. Unfortunately,
re-keying is an expensive operation. However, overwrite-averse LFS behavior
ensures costly re-keying operations are triggered as rarely as possible during
I/O, preserving or even improving system performance over other
approaches~\cite{StrongBox}.

\begin{figure}[ht]
   \centering
   \includegraphics[width=\linewidth]{flknug.png}
   \caption{Anatomy of a SwitchBox nugget.}\label{fig:flknug}
\end{figure}

As with prior work, SwitchBox divides the underlying drive into a series
same-size logical blocks called \emph{nuggets}, illustrated in \figref{flknug}.
A nugget consists of one or more physical drive blocks/sectors depending on its
configured size. Each nugget is subdivided into a constant number of units
called \emph{flakes}.

SwitchBox uses this flake-nugget structure to 1) track, detect, and handle
overwrites and 2) limit the maximum length of any plaintexts provided to
ciphers, thus amortizing the overhead incurred during expensive re-keying and
other operations when overwrites do occur~\cite{StrongBox}.

\subsection{Key Insights}

\subsubsection{A Single Point In A Space Of Possible Cipher Configurations}

What if, rather than restricting the system to a single cipher, we wanted to
\textit{flexibly} encrypt data at rest with a range of ciphers and cryptographic
keys at the block device level? Implementing a generic cipher API and
low-overhead switching mechanism allows for more than a single cipher to be used
on the same device, yielding a space of cipher configuration points with various
performance, battery life, security, writable space, and other tradeoffs where
prior work merely exists as a single point in this space.

\subsubsection{Nugget Encryption/Decryption And Re-Keying Is Entirely Independent}

With SwitchBox, nuggets are considered as distinct logical blocks, each with
their own metadata and unique cryptographic key used to encrypt and decrypt
their contents independent of other nuggets using the cipher chosen at system
initialization. This layout of distinct logical blocks naturally lends itself to
encrypting different portions of the underlying drive with different ciphers
instead; we can select any cipher to encrypt or decrypt any nugget at any point,
rather than just a single cipher applied globally across the backing store. This
design supports mixed cipher configurations such that each nugget can be encrypted,
decrypted, and switched independently from all other nuggets.

\subsubsection{Navigate The Configuration Space With \emph{Cipher Switching}}

Given a space of possible cipher configurations and a drive layout of
independent nuggets that lends itself to mixed cipher use, it is clear our
system does not have to sit at a static configuration point. Hence, we require a
mechanism to navigate the cipher configuration space, trading off concerns such
that the system is always at the most optimal configuration given the runtime
environment and user requirements. By abstracting the re-keying process out into
a \emph{re-ciphering} or \emph{cipher switching} process, whereby the key and
the cipher used to encrypt/decrypt the nugget can both be switched at runtime,
we can trade off between different ciphers and their characteristics
dynamically. Comparatively, prior work can only accomplish a static tradeoff at
compile time or at system initialization. \\
\\
Leveraging these insights, we present SwitchBox. \TODO{A few short explanatory
sentences that lead to: Our goal is to dynamically trade desirable security
properties for performance or energy.}

\subsection{Motivating Example: Filesystem Reacts to OS ``Battery Saver'' Mode}

\PUNT{\begin{figure}[ht] \textbf{Linearity Between Baseline Cipher Latency and Energy
Use}\par\medskip
   \centering
   {\input{charts/linearity-latency-energy.tex}} \caption{Comparison of cipher
   configuration median sequential and random latency versus median total energy
   use per I/O operation size (4KB, 512KB, 5MB, 40MB) without switching. The
   relationship between latency and total energy use is linear for the cipher
   configurations we examine in this paper.}
  \label{fig:linearity-latency-energy}
\end{figure}}

Suppose we are continually streaming a high-resolution video stored on our
mobile device to several WiFi connected devices, such as televisions or
projectors. We stored the video and other data on our device drive as securely
as possible, so we chose to initialize the system at a configuration point
offering very strong security.

For the ciphers examined in this paper, \figref{linearity-latency-energy} shows
a correlation between stronger security properties and greater total energy use,
meaning our device is using a lot more energy to facilitate FDE at this
configuration point. Though this correlation applies to the ciphers we examined,
note that this correlation is certainly not true for all possible ciphers.

Further suppose that, after a while of streaming, our device determines its
remaining battery life is too low and enters a ``battery saver'' mode with a
curtailed energy budget. With a traditional filesystem or encrypted container,
we are stuck with our high-energy configuration chosen at system initialization.

However, with the ability to operate at points along the pareto frontier (see
\figref{tradeoff-no-ratios}), even at points between the discrete configurations
available to prior work, a context-aware system can switch to a configuration
that trades the security of the portions of storage that are being used to
stream the video so that we stay within our curtailed energy budget.

When we return to a non-curtailed energy budget, the system can return to its
more secure configuration dynamically, allowing the cipher strength of the
backing store to eventually recover without having to recreate the entire
underlying filesystem or encrypted container.

\TODO{How does this example work?  If the video is originally stored with high security, then don't we have to decrypt it first and then re-encrypt at a different level?  Isn't the cost the read from high-security state?  I think we talked about this a while ago, but I don't remember the details.  My forgetfulness is actually good, because I can tell you that this example isn't going to do it without a lot more detail about why switching actually helps here.}

\subsection{Challenges}

\textbf{Comparing ciphers with disparate security properties.} To ensure that
these tradeoffs are made optimally, it is desirable to score the security
properties of various ciphers. This is challenging since different ciphers have
a wide range of energy/latency vs security properties, including ciphers that
are and are not length-preserving. Hence, cipher configurations will not form a
continuous tradeoff space in any scheme and so represent discrete points, yet
the desired energy, latency, or security state may lie between these points.

To address this, we propose a method for quantitative cipher comparison in the
FDE context, and then present some empirical results showing the wide range of
security and energy tradeoffs that become available with various
state-of-the-art ciphers as a result.\\
\\
\textbf{Maintaining I/O performance with a mixed-cipher drive layout.} With
prior work, cipher configurations are typically fixed at the time the system is
booted or the filesystem or container is created~\cite{CiteAllTheFilesystems};
if requirements change online, at best the entire system requires a reboot
leading to down time and user dissatisfaction. At worst, before the reboot, the
filesystem or encrypted container has to be deleted and recreated. This is
rarely desirable. Hence, SwitchBox requires a generic \emph{cipher API}, IPC,
and a software mechanism that can re-cipher or \emph{switch} the cipher used to
encrypt and decrypt individual nuggets while maintaining low overhead and
acceptable performance. This mechanism should allow for a mixed-cipher drive
layout and provides the ``how'' to switch nuggets' ciphers.

To provide the ``when'' or ``where'', we implement and demonstrate a series of
novel cipher switching \textit{strategies} that, along with the ``pluggable''
cipher API and cipher switching mechanism, enable optimal navigation of the
tradeoff space of configurations. For instance, these strategies allow SwitchBox
to settle on points between the static cipher configurations in
\figref{tradeoff-no-ratios}.

\TODO{Might be able to piece this out into two challenges: common interface for
stream ciphers and cipher switching strategies; that last one might be able to
split into two on its own. Perhaps this challenge subsection should mirror the
layout of the design section?}
