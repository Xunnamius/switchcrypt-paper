\section{Motivation}\label{sec:motivation}

\subsection{Example: Filesystem Reacts to ``Battery Saver''}

\PUNT{\begin{figure}[ht] \textbf{Linearity Between Baseline Cipher Latency and
Energy Use}\par\medskip
   \centering
   {\input{charts/linearity-latency-energy.tex}} \caption{Comparison of cipher
   configuration median sequential and random latency versus median total energy
   use per I/O operation size (4KB, 512KB, 5MB, 40MB) without switching. The
   relationship between latency and total energy use is linear for the cipher
   configurations we examine in this paper.}
  \label{fig:linearity-latency-energy}
\end{figure}}

Suppose we have an ARM-based ultra-low-voltage netbook provided to us by our
employer. As this is an enterprise device, our employer requires that 1) our
drive is fully encrypted at all times and 2) our encrypted data is constantly
backed up to an offsite system. The industry standard in full drive encryption
is AES-XTS, so we initialize our drive with it. Given these requirements, three
primary concerns present themselves.

First, it is well known that FDE using AES-XTS adds significant latency and
power overhead to I/O operations, especially on mobile and battery-constrained
devices~\cite{google-engadget, android-M-mobile-motivation,
android-M-mobile-motivation-2}. To keep our drive encrypted at all times with
AES-XTS means we must accept this hit to performance and battery life. Worse, if
our device does not support hardware accelerated AES, performance can be
degraded even further; I/O latency can be as high as 3-5x~\cite{StrongBox}.
Hardware accelerated AES is hardly ubiquitous, and the existence of myriad
devices that do not support it cannot simply be ignored, hence Google's
investment in Adiantum~\cite{Adiantum}.

Second, AES-XTS was designed to mitigate threats to drive data ``at rest,''
which implies an attacker cannot access snapshots of our encrypted data nor
manipulate that data without it being immediately obvious to us. With access to
multiple snapshots of a drive's AES-XTS-encrypted contents, an attacker can
passively glean information about the plaintext over time, possibly violating
data confidentiality~\cite{XEX, XTS}. Similarly, an attacker that can flip
encrypted bits without drawing our attention will corrupt any eventual
plaintext. Unfortunately, in real life, data rarely remains ``at rest'' in this
way. In our example, our employer requires we back up the contents of our drive
to some offsite backup service. This service will receive periodic snapshots of
the encrypted state of our drive, violating our invariant.

Third, our system is battery constrained, placing a cap on our energy budget
that can change at any moment.

To alleviate the performance concern, we can choose a stream cipher like
ChaCha20 rather than the AES-XTS block cipher. Using StrongBox, an encryption
driver built for ChaCha20-based FDE, we can achieve on average a 1.7x speedup
and a commensurate reduction in energy use~\cite{StrongBox}.

When it comes to the security concern, StrongBox solves both the snapshot and
integrity problems by 1) never writing data encrypted with the same key to the
same location and 2) tracking drive state using a Merkle tree and monotonic
counter supported by trusted hardware to prevent rollbacks. This ensures data
manipulations cannot occur and guarantees confidentiality even when snapshots
are compared. Unfortunately, restoring from a backup necessitates a forced
rollback of drive state, potentially opening us back up to
confidentiality-violating snapshot comparison attacks~\cite{StrongBox}.

To truly address the security concern requires a cipher with an additional
security property: ciphertext randomization. Using Freestyle~\cite{Freestyle}, a
ChaCha20-based stream cipher that supports ciphertext randomization, we can
guarantee data confidentiality even after a rollback of drive state occurs. So,
we switch to an encryption driver that supports Freestyle.

Unfortunately, like AES-XTS, Freestyle has significant overhead compared to the
original ChaCha20. In exchange for stronger security properties, Freestyle is up
to 1.6x slower than ChaCha20, uses more energy, has a higher initialization
cost, and expands the ciphertext which reduces total writeable drive
space~\cite{Freestyle}.

Further complicating matters is our final concern: a constrained energy budget.
Our example system is battery constrained. Even if we accepted trading off
performance, drive space, and energy for security in some situations, in other
situations we might prioritize reducing total energy use. For example, when we
trigger ``battery saver'' mode, we expect our device to conserve as much energy
as possible. It would be ideal if our device could pause backups and the
encryption driver could switch from the ciphertext randomizing Freestyle
configuration back to our high performance energy-efficient ChaCha20
configuration when conserving energy is a top priority, and then switch back to
the Freestyle configuration when we connect to a charger and backups are
eventually resumed.

With SwitchCrypt, we can dynamically trade off between these two configurations
and others without compromising security or performance or requiring the device
be restarted.

\subsection{Key Challenges}

To trade off between different cipher configurations, we must address three key
challenges. First, we must determine what cipher configurations are most
desirable in which contexts and why. This requires we \emph{quantify} the
desirable properties of these configurations. Second, we must have some way to
encrypt independent storage units with any one of these configurations. This
requires we \emph{decouple} cipher implementations from the encryption process
used in prior work. Third, we need to determine when to re-encrypt those units,
which configuration to use, and where to store the output, all with minimal
overhead. This requires we implement efficient cipher \emph{switching
strategies}.

\textbf{Quantifying the properties traded off between configurations.} To obtain
a space of configurations that we might reason about, it is necessary to compare
certain properties of stream ciphers useful in the FDE context. However,
different ciphers have a wide range of security properties, performance
profiles, and output characteristics, including those that randomize their
outputs and those with non-length-preserving outputs---\ie{the cipher outputs
more data than it takes in}. To address this, we propose a framework for
quantitative cipher comparison in the FDE context; we use this framework to
define our configurations.

\textbf{Decoupling ciphers from the encryption process.} To flexibly switch
between configurations in SwitchCrypt requires a generic cipher interface. This
is challenging given the variety of inputs required by various stream ciphers,
the existence of non-length-preserving ciphers, and other differences. We
achieve the required generality by defining independent storage units called
\emph{nuggets}; we borrow this terminology from prior work (see
\cite{StrongBox}) to easily differentiate our logical blocks (nuggets) from
physical drive and other storage blocks. And since they are independent, we can
use our interface to select any configuration to encrypt or decrypt any nugget
at any point.

\textbf{Implementing efficient switching strategies.} Finally, to determine when
to switch a nugget's cipher and to where we commit the output, we implement a
series of high-level policies we call \textit{cipher switching strategies}.
These strategies leverage our generic cipher interface and flexible drive layout
to selectively ``re-cipher'' groups of nuggets, whereby the key and the cipher
used to encrypt/decrypt a nugget are switched at runtime. These strategies allow
SwitchCrypt to move from one configuration point to another but settle on more
optimal cipher configurations unachievable with prior work. The challenge here
is to accomplish this while minimizing overhead.
