\section{SwitchBox Design}\label{sec:design}

\TODO{Restate that we're addressing our primary challenges (from motivation) in
three parts.}

In this section, we describe our mechanism to navigate the cipher
configuration space and cipher switching strategies. We also discuss the
pluggable stream cipher API and other design challenges.

\subsection{Mechanism to Re-Cipher A Nugget}

\begin{figure}[t]
   \centering
   \includegraphics[width=\linewidth]{overview.png}
   \caption{Overview of the SwitchBox construction.}\label{fig:overview}
\end{figure}

SwitchBox is a translation layer positioned between the block layer and the
operating system's virtual file system. Unlike StrongBox, which focuses on
optimizing performance despite re-keying due to overwrites, SwitchBox abstracts
the idea of re-keying out into re-ciphering or \emph{cipher switching}, where a
nugget's contents are decrypted using the old key and inactive cipher and
encrypted using a new key and the active cipher before completing the I/O
operation; instead of myopically pursuing a performance win, this allows us to
trade off different ciphers and their characteristics online.

\figref{overview} illustrates the SwitchBox design. SwitchBox manages five
metadata components: an in-memory \emph{Merkle Tree}; two drive-backed byte
arrays, \ie{the \emph{Keycount Store} and the \emph{Transaction Journal}}; a
globally persistent cryptographically secure monotonic counter; and a flexible
drive-backed store for cipher-specific \emph{per-nugget metadata}.

These five components are tightly integrated into the cryptographic driver,
which handles data encryption, decryption, overwrite detection, integrity
protection, communication with the wider system to determine the active cipher,
and the application of cipher switching strategies with stream cipher
implementations provided by the pluggable stream cipher API. The cryptographic
driver interacts with 1) the overlying LFS through traditional I/O passed
through the Linux Virtual Filesystem Switch (VFS) and 2) the underlying
backing store through the device controller block I/O layer.

By applying cipher switching strategies to individual nuggets so that their
contents are re-ciphered, the cryptographic driver provides a mechanism to
navigate the latency/energy/security tradeoff space of cipher configurations
with low overhead.

Since cipher switching is a cross-cutting concern (the desire to switch ciphers
could come from user space, for instance), SwitchBox uses IPC to receive
commands to toggle the active cipher.

\begin{figure}[t]
\centering
\includegraphics[width=\linewidth]{backstore.png}
 \caption{Layout of SwitchBox's backing storage.}\label{fig:backstore2}
\end{figure}

The backing store is the storage medium SwitchBox operates on. The layout of the
backing store is illustrated in \figref{backstore2}. In the \textit{body}
section of the backing store layout, end-user data is partitioned into a series
of same-size \emph{logical blocks} marked \textit{NUG} for \emph{nugget}. A
nugget consists of one or more physical drive blocks and per-nugget metadata
indicating which cipher was used to encrypt the nugget.

\subsection{Pluggable Stream Cipher API}

We develop an API to allow any stream cipher or any cipher that can pose as a
stream cipher to be used with SwitchBox without modification. In this way,
different stream ciphers might appear to all be interchangeable, but they are
not. Not all stream ciphers, let alone all ciphers, are length-preserving. A
length-preserving cipher generates ciphertext output of the same length as its
plaintext input, \eg{ChaCha20}. A cipher like Freestyle, on the other hand, is
not length-preserving and has the overhead of additional cryptographic material
that must be stored and indexed alongside any generated ciphertext. Hence, we
require a novel common interface that allows ciphers with different output
characteristics that would normally be entirely incompatible to co-exist on the
same drive.

SwitchBox exposes such a common encryption and decryption interface, including
read and write handles, that allow it to transition nuggets between arbitrary
ciphers.

\subsection{Cipher Switching Strategies}

At any moment, the currently active cipher is used to interact with the backing
store. Until the wider system indicates that SwitchBox should use a different
cipher to interact with the backing store, SwitchBox functions identically to
StrongBox in that it uses the active cipher (ChaCha20 in StrongBox's case) to
encrypt and decrypt all nuggets during I/O.

However, switching the active cipher dynamically allows SwitchBox to achieve
optimal configuration points that are otherwise unachievable with prior work.
Through IPC, the wider system determines which cipher should be the active
cipher at any given moment.

Unfortunately, when the wider system determines a cipher switch should occur for
whatever reason, it is entirely non-trivial to determine \emph{when} to
encrypt a nugget with a different cipher and \emph{where} to direct the
output of that cipher. A simple approach would immediately convert every nugget
in the backing store, but the cost of doing that conversion would likely consume
more energy than would be saved in future accesses; the egregious latency
penalty incurred waiting for the entire drive to be re-ciphered would be
similarly unacceptable. Hence, a more strategic approach is necessary. Cipher
switching \emph{strategies} is an essential part of the mechanism by which
SwitchBox can efficiently transition nuggets between different encrypted states
without egregious penalties to latency or battery life, thus providing a
realistic mechanism to navigate the tradeoff space presented in
\figref{40mb-read}.

Determining \emph{when} to target a nugget for re-ciphering we call
\emph{temporal switching}, for which we propose the \emph{Forward} switching
strategy and its variants. Determining \emph{where}---in which partition and
across which nuggets--to output ciphertext we call \emph{spatial switching} for
which we propose the \emph{Mirrored} and \emph{Selective} switching strategies.
Each comes with various security, performance, and energy trade offs.
\tblref{strategies-advantages} summarizes the various advantages and
disadvantages of these strategies and each strategy.

\begin{table}[]
   \begin{tabular}{@{}lll@{}}
   \toprule
   \textbf{Strategy} & \textbf{Advantages} & \textbf{Disadvantages} \\ \midrule
   Forward       & X      & Y \\
   Mirrored      & A     & B \\
   Selective     & C     & D \\
   \end{tabular}
   \caption{\TODO{Table caption goes here.}}
   \label{tbl:strategies-advantages}
\end{table}

\subsubsection{Forward Switching Strategy}

SwitchBox allows each individual nugget to exist encrypted with any cipher the
pluggable cipher API makes available regardless of the currently active cipher.
When a nugget is encountered during I/O that is encrypted using a cipher other
than the active cipher, however, the forward strategy dictates that this nugget
be re-ciphered. If a particular nugget encrypted with a non-active cipher is
never encountered during I/O, it is never re-ciphered and remains on the backing
store in its original state. In this way, the forward strategy represents a form
of temporal cipher switching.

Rather than re-cipher the entire backing store every time the active cipher
changes, this strategy limits the performance impact of cipher switching to
individual nuggets. Similar to re-keying in the original StrongBox construction,
the heavy price of re-ciphering is paid only once, after which the nugget is
accessed normally during I/O until the active cipher is switched again.

There are several forms the forward strategy can take. The default and most
intuitive is \emph{0-forward}, in which SwitchBox immediately transitions
individual nuggets encountered during I/O to the active cipher if they are not
using it. Over time, if various I/O operations end up touching every nugget in
the backing store, the encrypted contents of every nugget will become
decryptable with the currently active cipher.

The forward strategy can also take the form of \emph{N-forward}, where SwitchBox
attempts to take advantage of spatial sequential locality to transition whole
sets of nuggets into the active cipher. We can trivially expand the forward
strategy to encompass the entire backing store by selecting $N$ equal to the
total number of nuggets managed by SwitchBox. This would have the overhead of
re-ciphering large swaths of the backing store upon every I/O operation where a
nugget encrypted with the non-active cipher is encountered. Of course, this has
the same effect as simply re-initializing the entire filesystem with the new
cipher.

\subsubsection{Selective Switching Strategy}

When SwitchBox is initialized with the selective strategy, the backing store is
partitioned into $C$ regions where $C$ represents the number of ciphers in use;
each region's nuggets are encrypted by each of the $C$ ciphers respectively. For
instance, were SwitchBox initialized using two ciphers, the backing store would
be partitioned in half; all nuggets in the first partition would be encrypted
with the first cipher while all nuggets in the second partition would be
encrypted with the second.

Hence, unlike the forward strategy, which schedules individual nuggets to be
re-ciphered at some point in time \emph{after} the active cipher is switched,
the selective strategy allows the wider system to indicate \emph{where} on the
backing store a read or write operation should occur. In this way, the selective
strategy represents a form of spatial cipher switching where different regions
of the backing store can store different pieces of data encrypted with different
ciphers.

\subsubsection{Mirrored Switching Strategy}

Similar to the selective strategy, when SwitchBox is initialized with the
mirrored strategy, the backing store is partitioned into $C$ regions where $C$
represents the number of ciphers in use; each region's nuggets are encrypted by
each of the $C$ ciphers respectively. THe nuggets in each partition are
encrypted with their respective ciphers.

However, unlike the selective strategy, all write operations that hit one
partition are mirrored into the other partitions immediately. The mirrored
strategy allows the wider system to indicate where on the backing store a
\emph{read} operation should occur. In this way, the mirrored strategy, like the
selective strategy, represents a form of spatial cipher switching. All regions
of the backing store will always be in a consistent state and share the same
data.

\subsection{Additional Challenge: Beware Naive Forward Switching}

It is tempting to implement forward switching such that a nugget is completely
re-ciphered during I/O every time its metadata indicates that it was previously
encrypted using a non-active cipher. However, such a naive implementation can
have disastrous effects on performance depending on the workload.

First, a nugget is considered \emph{pristine} if it has not had any data written
into it yet. SwitchBox determines if a nugget is pristine by checking the state
of the transaction journal for that nugget. A pristine nugget will have a clean
transaction journal.

All nuggets start out as pristine. All nuggets start out with metadata
indicating that they're to be encrypted and decrypted by the initially active
cipher. This is true \emph{even if the nugget has not been written to yet}. This
means, on read and write operations after a different cipher becomes the
active cipher using a naively implemented forward switching strategy, every
write operation will trigger a re-keying, which carries significant overhead.

The solution is to divide forward switching into \emph{soft re-ciphering} and
\emph{hard re-ciphering}. Fortunately, the SwitchBox design lends itself nicely
to such a distinction for free, as per-nugget metadata is managed separately
from a nugget's actual data.

During soft re-ciphering, only the nugget's metadata is changed to indicate that
the nugget can be encrypted and decrypted with the newly active cipher but
\emph{without actually re-ciphering the nugget data itself}. This keeps the
nugget in its pristine condition, preserving SwitchBox's ability to write data
into it without triggering a costly re-keying operation every time, preserving
the original StrongBox's performance advantage. At the same time, SwitchBox can
now use the newly active cipher to interact with the nugget as expected.

On the other hand, during hard re-cipher, the nugget's metadata is changed to
match the active cipher \emph{and} the nugget data is encrypted using the new
cipher. When using forward switching other that 0-forward, \ie{N-forward} where
$N > 0$, only read operations are allowed to trigger hard re-ciphering for
nuggets other than the currently active nugget. This is still not enough to
preserve StrongBox's performance advantage, however, as I/O operations can span
multiple nuggets, and attempting to take advantage of spatial locality after
interacting with every nugget is counterproductive. Hence, only the last nugget
touched by a read operation will trigger the more aggressive N-forward behavior
if $N > 0$.

These considerations have the effect of 1) preserving the original StrongBox
performance advantage and 2) allowing more aggressive N-forward behavior (where
$N > 0$) to take advantage of spatial locality during read-heavy workloads to
result in a further performance advantage (c.f. \secref{evaluation}).

\subsection{A Relative Scoring of Cipher Security For SwitchBox FDE}

Any block cipher (in a proper mode) or stream cipher can be used with SwitchBox.
With this research, we select five popular cipher algorithms and implement them
under Switchbox in various configurations: ChaCha~\cite{ChaCha20} (ChaCha8,
ChaCha12, ChaCha20), Salsa~\cite{SalsaX} (Salsa8, Salsa12, Salsa20),
AES~\cite{AES} (AES-128, AES-256), HC128/HC256~\cite{HCX}, and
Freestyle~\cite{Freestyle}. Each cipher has been proven formally secure in that
there are no known efficient attacks against them. However, to simplify
reasoning about trading off the ``security'' provided by the various stream
cipher configurations in the FDE context, we must have a way to quantitatively
compare the benefits of some relevant subset of otherwise disparate security
properties and cipher configurations. Hence, we do not attempt to define a
generally applicable ranking of cipher security for FDE. Instead, we consider
three key features that when summed yield a relative score given a cipher's
security properties when specifically compared to the other ciphers we selected
(see: \tblref{security-quant}).\\
\\
\textbf{1) Output randomization (OR).} A cipher with output randomization
generates different ciphertexts non-deterministically given the same key,
nonce, and message. This makes chosen-ciphertext (CCA) attacks, where the
ciphertext is in full control of the adversary, much more difficult in the
general FDE context, where key and nonce may be reused with the same message.
Additionally, the cipher need not be length-preserving.

This is a binary feature in that a cipher either outputs deterministically or
it does not. A cipher with non-deterministic output given the same key, nonce,
and message as inputs scores a 1 for this feature while a cipher with
deterministic output given the same input scores a 0.\\
\\
\textbf{2) Resistance to brute force and offline/dictionary attacks (RBF).}
All the ciphers we consider are resistant to ciphertext-only brute force and
dictionary attacks, which is paramount for the encryption of data at rest. We
narrowly define ``standard resistance'' versus brute-force and
offline/dictionary attacks with respect to the time taken to finish decrypting
ciphertext given an incorrect key versus a correct key; a cipher with standard
resistance to brute force and offline/dictionary attacks has no kind of
\emph{key-guessing penalty}~\cite{Freestyle}---the ciphertext is decrypted no
slower when given the incorrect key as it is when given the correct key.
Similarly, we consider ciphers with so-called ``enhanced resistance,'' where
they are expected to take longer to finish decrypting ciphertext given an
incorrect key versus a correct key with high probability.

Scores for this feature range from 0 to 1, where 0 represents no resistance,
0.5 represents standard resistance to brute-force and offline/dictionary
attacks, and 1 represents enhanced resistance.\\
\\
\textbf{3) Relative round count and key length (RR/RK).} The ciphers we examine
in this research are all constructed around the notion of \emph{rounds}, where a
higher number of rounds implies a stronger confidentiality guarantee. This
feature represents how many rounds the cipher executes compared to the accepted
``standard'' round count for that cipher. For instance, ChaCha8 is a reduced round
version of the standard ChaCha20. Variants are distributed evenly from 0-1. For
instance, ChaCha8 scores 0, ChaCha12 scores 0.5, and ChaCha20 scores 1\@.
\TODO{Tweak this language a bit.}

\begin{table}[]
  \begin{tabular}{@{}lllll@{}}
  \toprule
  \textbf{Cipher} & \textbf{OR} & \textbf{RBF} & \textbf{RR/RK} & \textbf{score} \\ \midrule
  ChaCha8     & 0      & 0.5     & 0       & 0.5      \\
  ChaCha12    & 0      & 0.5     & 0.5      & 1       \\
  ChaCha20    & 0      & 0.5     & 1       & 1.5      \\
  Salsa8     & 0      & 0.5     & 0       & 0.4      \\
  Salsa12     & 0      & 0.5     & 0.5      & 1      \\
  Salsa20     & 0      & 0.5     & 1       & 1.5      \\
  AES128-CTR   & 0      & 0.5     & 0       & 0.5      \\
  AES256-CTR   & 0      & 0.5     & 1       & 1.5      \\
  HC128      & 0      & 0.5     & 0       & 0.5      \\
  HC256      & 0      & 0.5     & 1       & 1.5      \\
  Freestyle (F)  & 1      & 1      & 0       & 2       \\
  Freestyle (B)  & 1      & 1      & 0.5      & 2.5      \\
  Freestyle (S)  & 1      & 1      & 1       & 3
  \end{tabular}
  \caption{\TODO{Table caption goes here.}}
  \label{tbl:security-quant}
\end{table}
